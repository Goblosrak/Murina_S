Отчет по лабораторной работе 2
Анализ производительности коллекций в C#
Выполнила: Мурина Софья К0709-23/3

Классы и структура проекта

    Тестеры производительности:
    1. "ListTester" - тестирование операций с "List<T>"
    2. "LinkedListTester" - тестирование операций с "LinkedList<T>"
    3. "QueueTester" - тестирование операций с "Queue<T>"
    4. "StackTester" - тестирование операций с "Stack<T>"
    5. "ImmutableListTester" - тестирование операций с "ImmutableList<T>"
    
    Тесты корректности:
    1. "CollectionsTests" - модульные тесты для проверки корректности операций
    
    Основной класс:
    1. "Program" - точка входа и запуска всех тестов
    
    Основные технологии
    1. .NET 8.0 - платформа разработки
    2. C# 11 - язык программирования
    3. Stopwatch API - высокоточное измерение времени выполнения
    
    Исследуемые операции
    1. Добавление элементов (в конец, в начало, в середину)
    2. Удаление элементов (из начала, из конца, из середины)
    3. Поиск элемента по значению
    4. Получение элемента по индексу (где применимо)
    
    Объем тестирования
    1. Размер коллекций: 500 000 элементов
    2. Количество итераций: 5 повторений для усреднения
    3. Измерение в мс
    
    Используемые библиотеки .NET
    1. System.Collections - основные изменяемые коллекции
    2. System.Collections.Immutable - неизменяемые коллекции
    3. System.Diagnostics - класс Stopwatch для замера времени
    4. System - базовые типы и функции
    
    Запуск проекта
        dotnet restore
        dotnet run

1. Подход к реализации замеров
    1.1 Методология тестирования
        Для объективной оценки производительности был реализован следующий подход:
        Единые условия тестирования: 
            все коллекции содержат одинаковое количество элементов: 500000
            Количество итераций для каждого теста: 5 раз
            Результаты усредняются для минимизации погрешностей
        Измерение времени:
            Используется класс Stopwatch из пространства имен System.Diagnostics
            Время измеряется в миллисекундах (мс)
        Тестируемые операции:
            Добавление элементов (в начало, середину, конец)
            Удаление элементов (из начала, середины, конца)
            Поиск элемента по значению
            Получение элемента по индексу (где применимо)
        Обеспечение воспроизводимости:
            Детерминированные входные данные
            Изоляция тестов друг от друга
            Использование xUnit для проверки корректности операций

2. Результаты замеров
    1.1 List (500000 элементов)
            Операция	          Среднее время (мс)	  
            Добавление в конец	     0.02-0.08	
            Добавление в начало	       45-80	
            Добавление в середину	   25-45	
            Удаление из конца	     0.01-0.05	
            Удаление из начала	       35-65	
            Удаление из середины	   20-40	
            Поиск элемента           	2-5	
            Получение по индексу	 0.001-0.005	

    1.2 LinkedList (500000 элементов)
            Операция	          Среднее время (мс)	
            Добавление в конец	      0.01-0.04	
            Добавление в начало	      0.01-0.04	
            Удаление из конца	      0.01-0.05	
            Удаление из начала	      0.01-0.04	
            Поиск элемента	           50-120	

    1.3 Queue (500000 элементов)
            Операция	           Среднее время (мс)
            Enqueue (добавление)	   0.02-0.06
            Dequeue (удаление)	       0.01-0.04	
            Поиск элемента	              2-6	

    1.4 Stack (500000 элементов)
            Операция	           Среднее время (мс)	
            Push (добавление)	       0.02-0.06	
            Pop (удаление)	           0.01-0.04	
            Поиск элемента	              2-6	

    1.5 ImmutableList (500000 элементов)
            Операция	           Среднее время (мс)	
            Добавление в конец	         10-25	
            Добавление в начало	         12-30	
            Поиск элемента	             0.5-2	
            Получение по индексу	     0.5-2	

3. Ключевые выводы для 500,000 элементов
    3.1 List
        Преимущества:
        Быстрый доступ по индексу (O(1))
        Эффективное добавление в конец (амортизированное O(1))
        Хорошая локальность кэша (элементы хранятся непрерывно)
        Недостатки:
        Медленное добавление/удаление в начале/середине (O(n))
        При расширении требует перераспределения памяти
        Рекомендации: Использовать, когда нужен частый доступ по индексу и добавление преимущественно в конец.

    3.2 LinkedList
        Преимущества:
        Быстрое добавление/удаление в начале и конце (O(1))
        Постоянное время вставки/удаления в любом месте (если есть ссылка на узел)
        Недостатки:
        Медленный доступ по индексу (O(n))
        Плохая локальность кэша
        Высокие накладные расходы на хранение указателей
        Рекомендации: Использовать, когда требуется частые вставки/удаления в начале/середине списка.

    3.3 Queue
        Преимущества:
        Оптимизирована для операций FIFO (First-In-First-Out)
        Быстрые операции Enqueue и Dequeue (O(1))
        Четкая семантика "очереди
        Недостатки:
        Только последовательный доступ
        Не поддерживает доступ по индексу
        Рекомендации: Использовать для обработки задач в порядке поступления (очереди сообщений, задания).

    3.4 Stack
        Преимущества:
        Оптимизирована для операций LIFO (Last-In-First-Out)
        Быстрые операции Push и Pop (O(1))
        Четкая семантика "стека"
        Недостатки:
        Только последовательный доступ (с конца)
        Не поддерживает доступ по индексу
        Рекомендации: Использовать для алгоритмов, требующих LIFO (обход деревьев, отмена действий).

    3.5 ImmutableList
        Преимущества:
        Потокобезопасность по умолчанию
        Предсказуемое состояние (неизменяемость)
        Эффективное создание новых версий через структурное разделение
        Недостатки:
        Более медленные операции модификации (O(log n))
        Высокое потребление памяти при частых изменениях
        Рекомендации: Использовать в многопоточных приложениях и функциональном программировании.

4. Рекомендации
    При работе с большими коллекциями (500,000+ элементов):

    1. Сложность алгоритмов (Big O) становится критичной - разница между O(1), O(log n) и O(n) огромна
    2. List<T> остается универсальным выбором, но требует осторожности с операциями O(n)
    3. LinkedList<T> очень специализирован - использовать только при частых вставках/удалениях
    4. ImmutableList<T> неожиданно эффективен для поиска в больших коллекциях
    5. Queue<T> и Stack<T> сохраняют свою эффективность для специализированных сценариев

